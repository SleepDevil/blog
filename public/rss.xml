<?xml version="1.0" encoding="utf-8"?>






<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>SleepDevil</title>
        <link>https://sunfangjie.com/</link>
        <description>SleepDevil的个人博客</description>
        <generator>Hugo 0.85.0 https://gohugo.io/</generator>
        
            <language>zh-CN</language>
        
        
            <managingEditor>sleepdevil2zhu@gmail.com (SleepDevil)</managingEditor>
        
        
            <webMaster>sleepdevil2zhu@gmail.com (SleepDevil)</webMaster>
        
        
            <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
        
        <lastBuildDate>Mon, 29 Nov 2021 09:27:24 &#43;0800</lastBuildDate>
        
            <atom:link rel="self" type="application/rss&#43;xml" href="https://sunfangjie.com/rss.xml" />
        
        
            <item>
                <title>Typescript学习笔记</title>
                <link>https://sunfangjie.com/technology/typescript/</link>
                <guid isPermaLink="true">https://sunfangjie.com/technology/typescript/</guid>
                <pubDate>Wed, 13 Oct 2021 20:27:53 &#43;0800</pubDate>
                
                
                
                    <description>&lt;p&gt;最近对typescript十分着迷，找到一个很好的开源项目：&lt;a href=&#34;https://github.com/type-challenges/type-challenges&#34;&gt;type-challenges&lt;/a&gt;，本篇文章用来记录其中学习到的知识点。&lt;/p&gt;
&lt;h1 id=&#34;exclude工具类实现&#34;&gt;Exclude工具类实现&lt;/h1&gt;
&lt;p&gt;通过翻阅源码我们很容易看出实现代码：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-typescript&#34; data-lang=&#34;typescript&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/**
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * Exclude from T those types that are assignable to U
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; */&lt;/span&gt;
&lt;span class=&#34;kr&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Exclude&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;U&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;T&lt;/span&gt; &lt;span class=&#34;kr&#34;&gt;extends&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;U&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;?&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;never&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;但是这里面设计到的知识点还是不少的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;conditional type&lt;/p&gt;
&lt;p&gt;&lt;code&gt;extends&lt;/code&gt;关键字一般用在声明一个子类，而在类型编程中，可以用来继承一个interface。而这里的extends使用到了条件类型的判断，官网上是这样说的：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;When the type on the left of the &lt;code&gt;extends&lt;/code&gt; is assignable to the one on the right, then you’ll get the type in the first branch (the “true” branch); otherwise you’ll get the type in the latter branch (the “false” branch).&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;即当extends左边为右边的子类型（可以赋值给右边的类型）时，则为true，返回第一个值，否则返回第二个值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Distributive Conditional Types&lt;/p&gt;
&lt;p&gt;当我们测试我们的Exclude工具类型时：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-typescript&#34; data-lang=&#34;typescript&#34;&gt;&lt;span class=&#34;kr&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Test&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Exclude&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;a&amp;#39;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;b&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;a&amp;#39;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// type Test = &amp;#34;b&amp;#34;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;这时候可以看出，Test的类型为&lt;code&gt;&amp;quot;b&amp;quot;&lt;/code&gt;，&lt;code&gt;&#39;a&#39; | &#39;b&#39;&lt;/code&gt;是不可以赋值给右边的&lt;code&gt;&#39;a&#39;&lt;/code&gt;类型的，按理论上来说Test会返回第一个类型，也就是&lt;code&gt;&#39;a&#39; | &#39;b&#39;&lt;/code&gt;，但是并不是这样的。这里就涉及到了第二个知识点，当conditional type遇到联合类型（union type）时会触发distributive conditional types，即每一个联合类型里的类型都会进行一次条件判断，所以上面的类型判断逻辑实际是：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-typescript&#34; data-lang=&#34;typescript&#34;&gt;&lt;span class=&#34;kr&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Test&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; 
  &lt;span class=&#34;o&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;a&amp;#39;&lt;/span&gt; &lt;span class=&#34;kr&#34;&gt;extends&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;a&amp;#39;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;?&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;never&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// never
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;o&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;b&amp;#39;&lt;/span&gt; &lt;span class=&#34;kr&#34;&gt;extends&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;a&amp;#39;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;?&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;never&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// &amp;#39;b&amp;#39;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;所以最终，Test的类型为&lt;code&gt;&#39;b&#39;&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参考：&lt;a href=&#34;https://segmentfault.com/q/1010000021544352&#34;&gt;typescript内置Exclude怎么去理解?&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.typescriptlang.org/docs/handbook/2/conditional-types.html&#34;&gt;Conditional Types&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;keyof&#34;&gt;keyof&lt;/h1&gt;
</description>
                
                
                
                
                
                    
                        
                    
                        
                    
                
            </item>
        
            <item>
                <title>记一次react网络请求优化&#43;上传组件极致体验优化</title>
                <link>https://sunfangjie.com/technology/react_perf/</link>
                <guid isPermaLink="true">https://sunfangjie.com/technology/react_perf/</guid>
                <pubDate>Thu, 30 Sep 2021 19:27:18 &#43;0800</pubDate>
                
                
                
                    <description>&lt;h1 id=&#34;记一次react网络请求优化上传组件极致体验优化&#34;&gt;记一次react网络请求优化+上传组件极致体验优化&lt;/h1&gt;
&lt;h2 id=&#34;一网络请求优化&#34;&gt;一：网络请求优化&lt;/h2&gt;
&lt;p&gt;本次做的是一个素材库组件，这里面涉及到网路请求的其实就三个地方：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;全部图片tab&lt;/li&gt;
&lt;li&gt;最近使用tab&lt;/li&gt;
&lt;li&gt;上传图片后再次拉取全部图片tab数据&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由于该组件为独立组件，并且需要有分页功能，所以本次数据请求不是在点击按钮之后发送，而是通过&lt;code&gt;useEffect&lt;/code&gt;监听当前页码，当页码改变时拉取当前tab下的数据。关键代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;useEffect(() =&amp;gt; {
  loadData(); // 加载数据
}, [currentAllPage]); // 当前页码
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里就延伸出了第一个部分的网络优化：useState生成的变量初始值为&lt;code&gt;undefined&lt;/code&gt;，随后会被赋值为我们传入的初始值。所以这里会发现，两个tab会发出四次网络请求，每一个tab会重复发出一次请求，这一次就是我们的&lt;code&gt;currentAllPage&lt;/code&gt;从&lt;code&gt;undefined&lt;/code&gt;变为初始值第一页即&lt;code&gt;1&lt;/code&gt;时所发出的。这里一开始困扰了我很久，后来debug之后才知道是这里出了问题。解决方法：如果我们可以获取到&lt;code&gt;currentAllPage&lt;/code&gt;变量变化之前的值，并判断；如果它是undefined，则说明它还没有初始化完成，则此时return，不发起网络请求。那么问题就来到了如何在&lt;code&gt;useEffect&lt;/code&gt;中获取到依赖数组变化之前的值。我们都知道，当写class组件时，可以很方便的通过&lt;code&gt;getSnapshotBeforeUpdate&lt;/code&gt;和&lt;code&gt;getDerivedStateFromProps&lt;/code&gt;生命周期来获取变化之前以及变化之后的值。而到了函数式组件时，该怎么办呢？答案就是&lt;code&gt;hooks&lt;/code&gt;。hooks本质上解决的问题就是函数式组件没有办法像class组件一样保存状态，有了hooks，我们就可以保存组件更新之前的状态，直接上代码：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-typescript&#34; data-lang=&#34;typescript&#34;&gt;&lt;span class=&#34;kd&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;usePrevious&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;value&lt;/span&gt;: &lt;span class=&#34;kt&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;T&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;undefined&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;kr&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ref&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;useRef&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;();&lt;/span&gt;
  &lt;span class=&#34;nx&#34;&gt;useEffect&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;ref&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;current&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;});&lt;/span&gt;

  &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ref&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;current&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kr&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;prevState&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;usePrevious&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 使用方法
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;思路是：通过&lt;code&gt;useRef&lt;/code&gt; hook来保存该变量，并通过&lt;code&gt;useEffect&lt;/code&gt;监听，每当value发生变化，则改变ref.current内容为最新的value。而由于useEffect内部执行的代码是异步的，所以return出去的&lt;code&gt;ref.current&lt;/code&gt;为变化之前的值。这里其实同样可以使用&lt;code&gt;useState&lt;/code&gt;来进行保存，但是缺点是会多发生一次组件的重绘（虽然可以通过别的手段来进行优化，但是没有必要），造成性能下降。有了&lt;code&gt;usePrevious&lt;/code&gt;这个自定义hook，我们就可以获取变化之前变量的值了，那么我们的网络请求也就可以避免浪费了，直接上代码：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;9
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-typescript&#34; data-lang=&#34;typescript&#34;&gt;&lt;span class=&#34;kr&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;prevAllPage&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;usePrevious&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;number&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;currentAllPage&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;

&lt;span class=&#34;nx&#34;&gt;useEffect&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;typeof&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;prevAllPage&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;===&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;undefined&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;c1&#34;&gt;// 此时变量为初始化阶段
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
  &lt;span class=&#34;nx&#34;&gt;loadData&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 加载数据
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;},&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;currentAllPage&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 当前页码
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;这样就避免了两次无效的网络请求。&lt;/p&gt;
&lt;p&gt;你以为这就完了吗？不，还没完。&lt;/p&gt;
&lt;p&gt;回到我们一开始的业务需求：&lt;/p&gt;
&lt;p&gt;可以看到，有一个经常使用的tab。当我们从全部图片中选择了几张插入到我们的编辑器后，这几张插入的图片就应该出现在经常使用tab下，也就是说，经常使用tab在每一次modal打开后，都需要拉取最新的数据，而全部图片则不用。你可能觉得这很简单啊，直接监听modal的visible，为true的时候拉取一下不就行了吗？上代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const [shouldReloadRecentlyUsed, setShouldReloadRecentlyUsed] = useState&amp;lt;boolean&amp;gt;(false);

useEffect(() =&amp;gt; {
  if (props.visible === true) {
    // 仅当可见时更改数据，触发useEffect，从而更新最近使用数据
    setShouldReloadRecentlyUsed(prev =&amp;gt; !prev);
    setShowTime(prev =&amp;gt; prev + 1);
  }
}, [modalVisible]);

const prevShouldReloadRecently = usePrevious&amp;lt;boolean&amp;gt;(shouldReloadRecentlyUsed);

useEffect(() =&amp;gt; {
  if (typeof prevShouldReloadRecently === &#39;undefined&#39;) {
    return;
  }
  loadRecentlyUsedMedia();
  setSelectedItem({});
  setSelectedArr([]);
  // eslint-disable-next-line react-hooks/exhaustive-deps
}, [shouldReloadRecentlyUsed]);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;确实很简单，但是有一个小问题：当第一次打开时，loadData函数会一次性请求两个tab的数据，而同样会触发shouldReloadRecentlyUsed，也就是我们又多请求了一次最近使用tab下的资源。解决方法，添加一个showTime变量用来记录页面展示的次数，当该组件第一次展示时，return即可，这里代码较为简单，可以自行实现。总结了一下，重复的网络请求主要原因为useEffect使用不当导致，一旦依赖数组里变量过多，或useEffect过多，则会让人摸不清头脑。&lt;/p&gt;
&lt;p&gt;顺带提一下，最近学习mobx库时发现这样做分页会比监听页码变化后再回掉中拉取数据会更好，作者的原话为：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Reacting to state changes is always better then acting on state changes.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这其实也是符合hooks与react的理念的，声明式编程、declarative，确实妙啊！&lt;/p&gt;
&lt;h2 id=&#34;二上传体验优化&#34;&gt;二：上传体验优化&lt;/h2&gt;
&lt;p&gt;由于上传图片可以多选，当用户选多张的时候，如果没有反馈的话体验会很差。这里简单说一下解决方案。&lt;/p&gt;
&lt;p&gt;分两种情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;当前在第一页：&lt;/p&gt;
&lt;p&gt;在第一页的时候，上传体验是最好的，也是工作量最大的地方。方案是，在前面添加上传文件数量的占位骨架图并添加spin加载动画，当加载完成后替换掉对应图片并toast提示上传成功。这里由于我们已经通过骨架图来实现加载loading，所以在上传完之后不用再去拉取后端数据。随之而来的问题有两个：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;分页后计算上传成功的数量，并手动改变total变量。&lt;/li&gt;
&lt;li&gt;每一页只能有固定数量的图片，需要手动pop掉后面相同数量的图片，才能达到效果上一致。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当前在非第一页，此时则无需做任何操作，展示一个全局的loading，然后再文件全部上传完成后再刷新当前页码数据。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本次组件库的开发是第一次使用typescript + hooks来进行较为复杂组件的开发。在上传优化那一部分，涉及到了对一个复杂数组的细粒度更新，一开始是通过深拷贝一个本地数组再对本地数组进行更新，后来发现会被react的batchUpdate给合并，从而达不到一个一个从loading为true变为false。然后改为通过传入函数的方式来获取之前的状态并通过map手动修改。后续了解到可以通过引入mobx、immer等库来实现。当然，这些都是后话了。这篇文章一开始是有图片的，但是图片保存在公司电脑上忘记拷贝了，所以就没了。。。&lt;/p&gt;
</description>
                
                
                
                
                
                    
                        
                    
                        
                    
                
            </item>
        
    </channel>
</rss>
